<!-- TUC Computer Graphics Course Sandbox -->

</script><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TUC Graphics - WebGL Sandbox</title>

<!-- external libraries for matrix calculations and maintenance -->
<script type="text/javascript" src="./sandbox_files/glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="./sandbox_files/webgl-utils.js"></script>

<!-- Code for the vertex shader-->
<script id="shader-vs" type="x-shader/x-vertex">
//attributes for the vertex shader (different for every thread/core that will execute a copy of this)
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;

	//ModelView and Projection Matrices
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

	//Variable to be forwarded to the corresponding thread of the fragment shader
    varying vec4 vColor;

	//main function of the vertex shader
	//this code will be copied to many shader cores/threads and executed with the associated
	//data for every vertex (matrices, color, etc)
    void main(void) {
	
	//Each vertex is multiplied with the ModelView and Projection matrices and created a fragment
	    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		//Its color is forwarded to the fragment shader
        vColor = aVertexColor;
    }
</script>

<!-- Code for the fragment shader-->
<script id="shader-fs" type="x-shader/x-fragment">
    //necessary code for compatibility
	precision mediump float;

	//Variable coming from the vertex shader
    varying vec4 vColor;

    void main(void) {
	//the fragment gets its color value.
	//in the fragment shader many advanced shading algorithms can be implemented (Phong etc..)
        gl_FragColor = vColor;
    }
</script>

<script>

  function changeBg(){
        	document.body.style.backgroundImage="url('basic_background.jpg')";
			document.body.style.backgroundRepeat="no-repeat";		
	 }
</script>

<script>

  function changeBg2(){
        	document.body.style.backgroundImage="url('mountain_with_keys_red_no_sound.gif')";		
			document.body.style.backgroundRepeat="no-repeat";			
	 }
</script>

<script>

  function changeBg3(){
        	document.body.style.backgroundImage="url('mountain_with_keys_red.gif')";	
			document.body.style.backgroundRepeat="no-repeat";				
	 }
</script>

<script>

  function Game_Over(){
        	document.body.style.backgroundImage="url('game_over.gif')";	
			document.body.style.backgroundRepeat="no-repeat";	
	 }
</script>

<script>
  function play(){
	player.play();
  }
  
  function pause(){
	player.pause();
  }
  
  function stop(){
	player.currentTime = 0;
  }
</script>

<script>
  function play_over(){
	over.play();
  }
  
  function pause_over(){
	over.pause();
  }
  
  function stop_over(){
	over.currentTime = 0;
  }
</script>

<script>
  function play_glin(){
	player_glin.play();
  }
  
  function pause_glin(){
	player_glin.pause();
  }
  
  function stop_glin(){
	player_glin.currentTime = 0;
  }
</script>

<audio id="player">
	<source src="dm3.mp3" />
	<source src="dm3.ogg" />
</audio>

<audio id="over">
	<source src="game_over.mp3" />
	<source src="dm3.ogg" />
</audio>

<audio id="player_glin">
	<source src="glin.mp3" />
	<source src="glin.ogg" />
</audio>

<!-- Javascript code for the main functionality of the WebGL application-->
<script type="text/javascript">

    //the variable that will accommodate the WebGL context
	//every call to the state machine will be done through this variable
    var gl;

	//Initialize WebGL
    function initGL(canvas) {
        try {
		//get a webgl context
            gl = canvas.getContext("experimental-webgl");
			//assign a viewport width and height based on the HTML canvas element properties
			//(check last lines of code)
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
			//any error is handled here
			//all errors are visible in the console (F12 in Google chrome)
				
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }


	//Find and compile shaders (vertex + fragment shader)
    function getShader(gl, id) {
	//gets the shader scripts (vertex + fragment)
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
		//create shaders
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

		//ask WebGL to compile shaders
		//we check for errors here too
		//all errors are visible in the console (F12 in Google chrome)
        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }
	
    var shaderProgram;

	//Creates a program from a vertex + fragment shader pair
    function initShaders() {
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
		//link the compiled binaries
        gl.linkProgram(shaderProgram);

		//check for errors, again
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

		//activate current program
		//this sandbox has only on shader pair
		//we can have as many as we wish in more complex applications
        gl.useProgram(shaderProgram);

		//Update attributes for the vertex shader
		//attributes are accessible only from the vertex shader
		//if we want accessible data from a fragment shader we can use uniform variables,
		//or varyings that will be forwarded from the vertex shader to the fragment shader
		
		//Vertex position data
        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

		//Vertex color data
        shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
        gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);

		//Update uniform variables
		//this variables can be accessed from both the vertex and fragment shader
        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
    }


	//ModelView and Projection matrices
	//mat4 comes from the external library
    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();

	//The matrix stack operation are implemented below to handle local transformations
	
	//Push Matrix Operation
    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }

	//Pop Matrix Operation
    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }


	//Sets + Updates matrix uniforms
    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
    }


	//Rotation function helper
	function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }


	//Vertex, Index and Color Data
    var cubeVertexPositionBuffer; // contains coordinates
    var cubeVertexColorBuffer; //contains color per vertex
    var cubeVertexIndexBuffer; //contains indices for chains of vertices to draw triangles/other geometry

	//Initialize VBOs, IBOs and color
    function initBuffers() {
        //Vertex Buffer Object
        cubeVertexPositionBuffer = gl.createBuffer();
		//Bind buffer to ARRAY_BUFFER
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        vertices = [
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
		//every item has 3 coordinates (x,y,z)
        cubeVertexPositionBuffer.itemSize = 3;
		//we have 24 vertices
        cubeVertexPositionBuffer.numItems = 24;

		//Color
        cubeVertexColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
        colors = [
            [1.0, 0.0, 0.0, 1.0], // Front face
            [1.0, 1.0, 0.0, 1.0], // Back face
            [0.0, 1.0, 0.0, 1.0], // Top face
            [1.0, 0.5, 0.5, 1.0], // Bottom face
            [1.0, 0.0, 1.0, 1.0], // Right face
            [0.0, 0.0, 1.0, 1.0]  // Left face
        ];
        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
			//assign colors for each vertex of each face based on the packed representation above
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
		//every color has 4 values: red, green, blue and alpha (transparency: use 1.0 (opaque) for this demo)
        cubeVertexColorBuffer.itemSize = 4;
		//24 color values (we have 24 vertices to color...)
        cubeVertexColorBuffer.numItems = 24;

		//Index Buffer Object
		//it joins sets of vertices into faces
        cubeVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        var cubeVertexIndices = [
		//this numbers are positions in the VBO array above
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
        //we have one item - the cube
		cubeVertexIndexBuffer.itemSize = 1;
		//we have 36 indices (6 faces, every face has 2 triangles, each triangle 3 vertices: 2x3x6=36)
        cubeVertexIndexBuffer.numItems = 36;
    }

	//Helper Variables
    var rCube = 0;
	
	var Depth1 = -100;
	var Depth2 = -75;
	var Depth3 = -50;
	var Depth4 = -25;
	
	var f1=0.0;
	var f2=0.0;
	var f3=0.0;
	var f4=0.0;

	var z1=0.0;
	var z2=0.0;
	var z3=0.0;
	var z4=0.0;
	
	var xTrans = 0.0;
	var yTrans = 0.0;
	var coordinates =0.0;////////////////////////////////////
	var check =0.0;
	var listen =1.0;
	
	var ii=0.0;
	var yy=0.0;
	var BeginAgain=0.0;
	var cc=0.0;
	
	var t1=0.0;
	var t2=0.0;
	
	////// 1 depth
	
	var count=0.0;
	
	////// steiles an depth
	
	var a1=0.0;
	var a2=0.0;
	var a3=0.0;
	
	var b1=0.0;
	var b2=0.0;
	var b3=0.0;

	var c1=0.0;
	var c2=0.0;
	var c3=0.0;
	
	var d1=0.0;
	var d2=0.0;
	var d3=0.0;
	
	////// gia to upsos tou perasmatos
	
	var za1=0.0;
	var za2=0.0;
	var za3=0.0;
	
	var zb1=0.0;
	var zb2=0.0;
	var zb3=0.0;

	var zc1=0.0;
	var zc2=0.0;
	var zc3=0.0;
	
	var zd1=0.0;
	var zd2=0.0;
	var zd3=0.0;
	
	var timer = 0.0;
	
	var distance=0.0;
	var end=0.0;
	var beg=0.0;
	
	var score=0.0;
	var score_c=5.0;
	var speed=75;
	
	var s1_a=0.0;
	var s1_b=0.0;
	var s1_c=0.0;
	
	var s2_a=0.0;
	var s2_b=0.0;
	var s2_c=0.0;
	
	var s3_a=0.0;
	var s3_b=0.0;
	var s3_c=0.0;
	
	var s4_a=0.0;
	var s4_b=0.0;
	var s4_c=0.0;
	
	var normal_cam=1.0;
	
	var panoramic_cam_x=0.0;
	var panoramic_bird_x=0.0;
	
	var panoramic_cam_y=0.0;
	var panoramic_bird_y=0.0;	
	
	var restart_game=0;
	var stop_animation=0;

	var wings=true;
	
	window.addEventListener("keydown", checkKeyPressed, false);
	window.addEventListener("mousedown", fly, false);
	
	function fly(e){
	
	if(restart_game==0){
	
			timer=0.0;
			distance=0.0;
			beg=new Date().getTime();
			yTrans += 0.35;
		}
	}
 
	function checkKeyPressed(e) {
	
	if(check==1){
	
	if(restart_game==0){
	
		if (e.keyCode == "37" || e.keyCode == "65") {
		// Left cursor key
		   if (xTrans==0.0){
					xTrans=-3;
				}			
				else if(xTrans==3){
					xTrans=0.0;
				}
		}
		else if (e.keyCode == "39" || e.keyCode == "68") {
		// Right cursor key
		   if (xTrans==0.0){
					xTrans=3;
				}			
				else if(xTrans==-3){
					xTrans=0.0;
				}
		}
		else if (e.keyCode == "38" || e.keyCode == "87") {
		// Up cursor key
				timer=0.0;
				distance=0.0;
				beg=new Date().getTime();
				yTrans += 0.4;
		}
	}
	}
	else if(check==0){
		
		if (e.keyCode == "49") {
		// '1'
			normal_cam=1.0;
		}
		else if (e.keyCode == "50") {
		// '2'
			normal_cam=0.0;
		}
	}
	
	}
	
	////////////////////////
	
	//For every frame this function draws the complete scene from the beginning
    function drawScene() {
	//the viewport gets the canvas values (that were assigned to the gl context variable)
	
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
		//the frame and depth buffers get cleaned (the depth buffer is used for sorting fragments)
		//without the depth buffer WebGL does not know which fragment is visible for a given pixel
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

		//the projection matrix (pMatrix) is set
		//45 degrees Field-Of-View
		//aspect ratio gl.viewportWidth / gl.viewportHeight
		//near plane: 0.1 , far plane: 100
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

		//the modelview Matrix is initialized with the Identity Matrix
        mat4.identity(mvMatrix);
		
		//the ModelView matrix gets a global transformation ("camera" retracts 8 units)
		//otherwise the "camera" will be inside the rotating cube
		//z-axis points out of the screen. we translate -8 which is the inverse transform
		//in essence we move the world -8 units to have the camera 8 units forward.
		//REMEMBER there is no actual camera in WebGL
		if(normal_cam==1.0){
			// camera
			 mat4.translate(mvMatrix, [-(xTrans*2), 0.0, -8.0]);
		
			//we use the matrix stack to employ a local transformation to the cube
			mvPushMatrix();
			
			//a translation associated with the keyboard
			mat4.translate(mvMatrix, [2*xTrans, yTrans, 0.0]);
			
			//a rotation connected with animation parameters
			mat4.rotate(mvMatrix, degToRad(180), [0, 1, 0]);
		}
		else if(normal_cam==0){
			//camera
			mat4.translate(mvMatrix, [0, -2, -16.0]);
			
			//we use the matrix stack to employ a local transformation to the cube
			mvPushMatrix();
			
			//a translation associated with the keyboard
			mat4.translate(mvMatrix, [2*xTrans, yTrans, 0.0]);
			
			//a rotation connected with animation parameters
			mat4.rotate(mvMatrix, degToRad(180), [0, 1, 0]);
		}

		mat4.scale(mvMatrix, [0.1, 0.1, 0.1]);
		
		//we bind the buffer for the cube vertices
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

		//we bind the buffer for the cube colors
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);

		//we bind the buffer for the cube vertex indices
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
		
		//we update the uniforms for the shaders
        setMatrixUniforms();
		
		//we call the Draw Call of WebGL to draw the cube
		//Triangles mode
        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

		//we pop the matrix and now the active ModelView matrix is the global one
        mvPopMatrix();

	//////////////////////////////////////////////////////

			//ftera

	mvPushMatrix();
	mat4.translate(mvMatrix, [(2*xTrans)-0.065, yTrans, 0.0]);
	//mat4.translate(mvMatrix, [(2*xTrans), yTrans, 0.0]);

	mat4.rotate(mvMatrix, 3.14159265359 , [0, 1, 0]);

	mat4.translate(mvMatrix, [0.07, 0 , 0.0]);
	mat4.rotate(mvMatrix, degToRad(rCube+20), [0, 0, 1]);
	mat4.translate(mvMatrix, [0.07, 0 , 0.0]);

	
	
	mat4.scale(mvMatrix, [0.15, 0.02, 0.05]);
			
	setMatrixUniforms();
	gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
	mvPopMatrix();

////////to allo me - rcube












	//////////////////////////////////////////////////////

		
		for (ii = 0; ii < 14; ii+=6.0){
			
			if (ii==0){
				f1=a1;
				f2=b1;
				f3=c1;
				f4=d1;
			}
			else if(ii==6.0){
				f1=a2;
				f2=b2;
				f3=c2;
				f4=d2;
			}
			else{
				f1=a3;
				f2=b3;
				f3=c3;
				f4=d3;
			}
			
			mvPushMatrix();
			mat4.translate(mvMatrix, [ii - 6.0 , 2.0 , Depth1]);
			mat4.scale(mvMatrix, [0.5, f1, 0.35]);
			if (f1==1.5){
				mat4.translate(mvMatrix, [0 , 0.35 , 0]);
			}
			else if(f1==0.5){
				mat4.translate(mvMatrix, [0 , 2.55 , 0]);
			}
			else if(f1==2.5){
				mat4.translate(mvMatrix, [0 , -0.255 , 0]);
			}
			
			if (Depth1>=-3.5 && Depth1<=4){
			mat4.rotate(mvMatrix, 3.14159265359 , [0, 1, 0]);//peristrofh kata pi
			}
			else{
			mat4.rotate(mvMatrix, 3.14159265359 , [0, 0, 0]);
			}
			
			setMatrixUniforms();
			gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
			mvPopMatrix();
			
			mvPushMatrix();
			mat4.translate(mvMatrix, [ii - 6.0 , 2.0 , Depth2]);
			mat4.scale(mvMatrix, [0.5, f2, 0.35 ]);
			if (f2==1.5){
				mat4.translate(mvMatrix, [0 , 0.35 , 0]);
			}
			else if(f2==0.5){
				mat4.translate(mvMatrix, [0 , 2.55 , 0]);
			}
			else if(f2==2.5){
				mat4.translate(mvMatrix, [0 , -0.255 , 0]);
			}
			
			if (Depth2>=-3.5 && Depth2<=4){
			mat4.rotate(mvMatrix, 3.14159265359 , [0, 1, 0]);//peristrofh kata pi
			}
			else{
			mat4.rotate(mvMatrix, 3.14159265359 , [0, 0, 0]);
			}
			
			setMatrixUniforms();
			gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
			mvPopMatrix();
			
			mvPushMatrix();
			mat4.translate(mvMatrix, [ii - 6.0 , 2.0 , Depth3]);
			mat4.scale(mvMatrix, [0.5, f3, 0.35 ]);
			if (f3==1.5){
				mat4.translate(mvMatrix, [0 , 0.35 , 0]);
			}
			else if(f3==0.5){
				mat4.translate(mvMatrix, [0 , 2.55 , 0]);
			}
			else if(f3==2.5){
				mat4.translate(mvMatrix, [0 , -0.255 , 0]);
			}
			
			if (Depth3>=-3.5 && Depth3<=4){
			mat4.rotate(mvMatrix, 3.14159265359 , [0, 1, 0]);//peristrofh kata pi
			}
			else{
			mat4.rotate(mvMatrix, 3.14159265359 , [0, 0, 0]);
			}
			
			setMatrixUniforms();
			gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
			mvPopMatrix();
			
			mvPushMatrix();
			mat4.translate(mvMatrix, [ii - 6.0 , 2.0 , Depth4]);
			mat4.scale(mvMatrix, [0.5, f4, 0.35 ]);
			if (f4==1.5){
				mat4.translate(mvMatrix, [0 , 0.35 , 0]);
			}
			else if(f4==0.5){
				mat4.translate(mvMatrix, [0 , 2.55 , 0]);
			}
			else if(f4==2.5){
				mat4.translate(mvMatrix, [0 , -0.255 , 0]);
			}
			
			if (Depth4>=-3.5 && Depth4<=4){
			mat4.rotate(mvMatrix, 3.14159265359 , [0, 1, 0]);//peristrofh kata pi
			}
			else{
			mat4.rotate(mvMatrix, 3.14159265359 , [0, 0, 0]);
			}
			
			setMatrixUniforms();
			gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
			mvPopMatrix();
			}
		
		for (ii = 0; ii < 14; ii+=6.0){
		
			if (ii==0){
				z1=za1;
				z2=zb1;
				z3=zc1;
				z4=zd1;
			}
			else if(ii==6.0){
				z1=za2;
				z2=zb2;
				z3=zc2;
				z4=zd2;
			}
			else{
				z1=za3;
				z2=zb3;
				z3=zc3;
				z4=zd3;
			}
			
			mvPushMatrix();
			mat4.translate(mvMatrix, [ii - 6.0 , -2.0 , Depth1]);
			mat4.scale(mvMatrix, [0.5, z1, 0.35 ]);
			if (z1==1.5){
				mat4.translate(mvMatrix, [0 , -0.35 , 0]);
			}
			else if(z1==0.5){
				mat4.translate(mvMatrix, [0 , -2.55 , 0]);	
			}
			else if(z1==2.5){
				mat4.translate(mvMatrix, [0 , 0.255 , 0]);	
			}
			else if(z1==2.0){
				mat4.translate(mvMatrix, [0 , 0 , 0]);
			}
			
			if (Depth1>=-3.5 && Depth1<=4){
			mat4.rotate(mvMatrix, 3.14159265359 , [0, 1, 0]);//peristrofh kata pi
			}
			else{
			mat4.rotate(mvMatrix, 3.14159265359 , [0, 0, 0]);
			}
			
			setMatrixUniforms();
			gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
			mvPopMatrix();
			
			mvPushMatrix();
			mat4.translate(mvMatrix, [ii - 6.0 , -2.0 , Depth2]);
			mat4.scale(mvMatrix, [0.5, z2, 0.35 ]);
			if (z2==1.5){
				mat4.translate(mvMatrix, [0 , -0.35 , 0]);
			}
			else if(z2==0.5){
				mat4.translate(mvMatrix, [0 , -2.55 , 0]);	
			}
			else if(z2==2.5){
				mat4.translate(mvMatrix, [0 , 0.255 , 0]);	
			}
			else if(z2==2.0){
				mat4.translate(mvMatrix, [0 , 0 , 0]);
			}
			
			if (Depth2>=-3.5 && Depth2<=4){
			mat4.rotate(mvMatrix, 3.14159265359 , [0, 1, 0]);//peristrofh kata pi
			}
			else{
			mat4.rotate(mvMatrix, 3.14159265359 , [0, 0, 0]);
			}
			
			setMatrixUniforms();
			gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
			mvPopMatrix();
			
			mvPushMatrix();
			mat4.translate(mvMatrix, [ii - 6.0 , -2.0 , Depth3]);
			mat4.scale(mvMatrix, [0.5, z3, 0.35 ]);
			if (z3==1.5){
				mat4.translate(mvMatrix, [0 , -0.35 , 0]);
			}
			else if(z3==0.5){
				mat4.translate(mvMatrix, [0 , -2.55 , 0]);	
			}
			else if(z3==2.5){
				mat4.translate(mvMatrix, [0 , 0.255 , 0]);	
			}
			else if(z3==2.0){
				mat4.translate(mvMatrix, [0 , 0 , 0]);
			}
			
			if (Depth3>=-3.5 && Depth3<=4){
			mat4.rotate(mvMatrix, 3.14159265359 , [0, 1, 0]);//peristrofh kata pi
			}
			else{
			mat4.rotate(mvMatrix, 3.14159265359 , [0, 0, 0]);
			}
			
			setMatrixUniforms();
			gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
			mvPopMatrix();
			
			mvPushMatrix();
			mat4.translate(mvMatrix, [ii - 6.0 , -2.0 , Depth4]);
			mat4.scale(mvMatrix, [0.5, z4, 0.35 ]);
			if (z4==1.5){
				mat4.translate(mvMatrix, [0 , -0.35 , 0]);
			}
			else if(z4==0.5){
				mat4.translate(mvMatrix, [0 , -2.55 , 0]);	
			}
			else if(z4==2.5){
				mat4.translate(mvMatrix, [0 , 0.255 , 0]);	
			}
			else if(z4==2.0){
				mat4.translate(mvMatrix, [0 , 0 , 0]);
			}
			
			if (Depth4>=-3.5 && Depth4<=4){
			mat4.rotate(mvMatrix, 3.14159265359 , [0, 1, 0]);//peristrofh kata pi
			}
			else{
			mat4.rotate(mvMatrix, 3.14159265359 , [0, 0, 0]);
			}
			
			setMatrixUniforms();
			gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
			mvPopMatrix();
			}
    }
	
	//animation parameter
    var lastTime = 0;
    var cwings=0; 

	//Animate function
    function animate() {
	
        var timeNow = new Date().getTime();
		
        if (lastTime != 0) {
            var elapsed = timeNow - lastTime;
            //adjust a constant rotation speed independently of platform/framerate

		cwings=cwings+elapsed;	
			
		if(wings){
		 rCube -= (50 * elapsed) / 1000.0;
			}
		else{
           	 rCube += (50 * elapsed) / 1000.0;
			}
			
		if(cwings>1000){//miliseconds

			wings=!wings;
			cwings=0;
			}


		if(restart_game==0){
		
			if (score_c==score){
				score_c=score+5;
				speed=speed+6;
				console.log(score_c, speed);
			}
			
			//console.log(score);
			
			if (Depth1<4.0){
				Depth1+=((((speed * elapsed) / 1000.0)/10));
			}
			else{
				Depth1= -100;
				score++;
				RandColumns_1();
			}
			
			if (Depth2<4.0){
				Depth2+=((((speed * elapsed) / 1000.0)/10));
			}
			else{
				Depth2= -100;
				score++;
				RandColumns_2();
			}
			
			if (Depth3<4.0){
				Depth3+=((((speed * elapsed) / 1000.0)/10));
			}
			else{
				Depth3= -100;
				score++;
				RandColumns_3();
			}
			
			if (Depth4<4.0){
				Depth4+=((((speed * elapsed) / 1000.0)/10));
			}
			else{
				Depth4= -100;
				score++;
				RandColumns_4();
			}
			
		}
		else{
			Depth1=100;
			Depth2=100;
			Depth3=100;
			Depth4=100;
			yTrans=-800;
			
			if(stop_animation==0){
				pause();
				play_over();
				restart();
			}
		}
        }
        lastTime = timeNow;
		gravity();
		conflict();
    }
	
	function restart(){
	
		restart_game=1;
		stop_animation=1;
		Game_Over();
		
		window.addEventListener("mousedown", begin_again, false);
		alert("Your score is "+score+ " !!");
	}
	
	function begin_again(event){
	
				 canvas_x = event.pageX;
				 canvas_y = event.pageY;
				 
				 if ((543<canvas_x)&&(canvas_x<907) && (346<canvas_y)&&(canvas_y<430)){ // start game
					location.reload();
				 }
				 else if ((650<canvas_x)&&(canvas_x<820) && (470<canvas_y)&&(canvas_y<550)){ // quit
					alert("Have a flappy day :-)");
					var win = window.open("","_self"); /* url = "" or "about:blank"; target="_self" */
					win.close();
				 }
				 else if ((1705<canvas_x)&&(canvas_x<1903) && (853<canvas_y)&&(canvas_y<910)){ // credits
					alert("Sarantaris Eleftherios @TUC");
				 }
				 else{
				    //console.log(canvas_x, canvas_y);
				 }
	}
	
	
	function conflict(){

		if(Depth4>=-3.0 && Depth4<=-1.0){
			
			if(s4_a==1.0 && xTrans==-3.0){
			
				if(((yTrans>0.98) && (yTrans<2.35) && (d1==0.5)) || ((yTrans<-1.05) && (yTrans>-2.3) && (d1==2.5)) || ((yTrans>-0.4) && (yTrans<0.6) && (d1==1.5))){
				
					play_glin();
					console.log(yTrans);
				}
				else{
					restart_game=1;//game over
				}
			}
			else if(s4_b==1.0 && xTrans==0.0){
			
				if(((yTrans>0.98) && (yTrans<2.35) && (d2==0.5)) || ((yTrans<-1.05) && (yTrans>-2.3) && (d2==2.5)) || ((yTrans>-0.4) && (yTrans<0.6) && (d2==1.5))){
				
					play_glin();
					console.log(yTrans);
				}
				else{
					restart_game=1;//game over
				}
			}
			else if(s4_c==1.0 && xTrans==3.0){
			
				if(((yTrans>0.98) && (yTrans<2.35) && (d3==0.5)) || ((yTrans<-1.05) && (yTrans>-2.3) && (d3==2.5)) || ((yTrans>-0.4) && (yTrans<0.6) && (d3==1.5))){
				
					play_glin();
					console.log(yTrans);
				}
				else{	
					restart_game=1;//game over
				}
			}
			else{
				restart_game=1;//game over
			}
		}
		
		else if(Depth3>=-3.0 && Depth3<=-1.0){
			
			if(s3_a==1.0 && xTrans==-3.0){
			
				if(((yTrans>0.98) && (yTrans<2.35) && (c1==0.5)) || ((yTrans<-1.05) && (yTrans>-2.3) && (c1==2.5)) || ((yTrans>-0.4) && (yTrans<0.6) && (c1==1.5))){
				
					play_glin();
					console.log(yTrans);
				}
				else{
					restart_game=1;//game over
				}
			}
			else if(s3_b==1.0 && xTrans==0.0){
			
				if(((yTrans>0.98) && (yTrans<2.35) && (c2==0.5)) || ((yTrans<-1.05) && (yTrans>-2.3) && (c2==2.5)) || ((yTrans>-0.4) && (yTrans<0.6) && (c2==1.5))){
				
					play_glin();
					console.log(yTrans);
				}
				else{
					restart_game=1;//game over
				}
			}
			else if(s3_c==1.0 && xTrans==3.0){
			
				if(((yTrans>0.98) && (yTrans<2.35) && (c3==0.5)) || ((yTrans<-1.05) && (yTrans>-2.3) && (c3==2.5)) || ((yTrans>-0.4) && (yTrans<0.6) && (c3==1.5))){
				
					play_glin();
					console.log(yTrans);
				}
				else{
					restart_game=1;//game over
				}
			}
			else{
				restart_game=1;//game over
			}
		}
		
		else if(Depth2>=-3.0 && Depth2<=-1.0){
			
			if(s2_a==1.0 && xTrans==-3.0){
			
				if(((yTrans>0.98) && (yTrans<2.35) && (b1==0.5)) || ((yTrans<-1.05) && (yTrans>-2.3) && (b1==2.5)) || ((yTrans>-0.4) && (yTrans<0.6) && (b1==1.5))){
				
					play_glin();
					console.log(yTrans);
				}
				else{	
					restart_game=1;//game over
				}
			}
			else if(s2_b==1.0 && xTrans==0.0){
			
				if(((yTrans>0.98) && (yTrans<2.35) && (b2==0.5)) || ((yTrans<-1.05) && (yTrans>-2.3) && (b2==2.5)) || ((yTrans>-0.4) && (yTrans<0.6) && (b2==1.5))){
				
					play_glin();
					console.log(yTrans);
				}
				else{
					restart_game=1;//game over
				}
			}
			else if(s2_c==1.0 && xTrans==3.0){
			
				if(((yTrans>0.98) && (yTrans<2.35) && (b3==0.5)) || ((yTrans<-1.05) && (yTrans>-2.3) && (b3==2.5)) || ((yTrans>-0.4) && (yTrans<0.6) && (b3==1.5))){
				
					play_glin();
					console.log(yTrans);
				}
				else{
					restart_game=1;//game over
				}
			}
			else{
				restart_game=1;//game over
			}
		}
		else if(Depth1>=-3.0 && Depth1<=-1.0){
			
			if(s1_a==1.0 && xTrans==-3.0){
			
				if(((yTrans>0.98) && (yTrans<2.35) && (a1==0.5)) || ((yTrans<-1.05) && (yTrans>-2.3) && (a1==2.5)) || ((yTrans>-0.4) && (yTrans<0.6) && (a1==1.5))){
				
					play_glin();
					console.log(yTrans);
				}
				else{
					restart_game=1;//game over
				}
			}
			else if(s1_b==1.0 && xTrans==0.0){
			
				if(((yTrans>0.98) && (yTrans<2.35) && (a2==0.5)) || ((yTrans<-1.05) && (yTrans>-2.3) && (a2==2.5)) || ((yTrans>-0.4) && (yTrans<0.6) && (a2==1.5))){
				
					play_glin();
					console.log(yTrans);
				}
				else{
					restart_game=1;//game over
				}
			}
			else if(s1_c==1.0 && xTrans==3.0){
			
				if(((yTrans>0.98) && (yTrans<2.35) && (a3==0.5)) || ((yTrans<-1.05) && (yTrans>-2.3) && (a3==2.5)) || ((yTrans>-0.4) && (yTrans<0.6) && (a3==1.5))){
				
					play_glin();
					console.log(yTrans);
				}
				else{
					restart_game=1;//game over
				}
			}
			else{
				restart_game=1;//game over
			}
		}
	}
	
    function RandColumns_1() {
			
				t1=Math.random();
				
				if (t1<=0.33){ //gia thn prwth sthlh
				
				s1_a=1.0; //afou tha perasei apo thn prwth sthlh tou depth1
				s1_b=0.0;
				s1_c=0.0;
				
					t2=Math.random();
					if (t2<=0.33){// katw keno
						a1=1.5;
						za1=1.5;
						
						a2=2.0;
						za2=2.0;
						
						a3=2.0;
						za3=2.0;
					}
					else if((t2>0.33) && (t2<=0.66)){// mesaio keno
						a1=2.5;
						za1=0.5;
						
						a2=2.0;
						za2=2.0;
						
						a3=2.0;
						za3=2.0;
					}
					else if(t2>0.66){// panw keno
						a1=0.5;
						za1=2.5;
						
						a2=2.0;
						za2=2.0;
						
						a3=2.0;
						za3=2.0;
					}
				}
				else if((t1>0.33) && (t1<=0.66)){ //gia thn deuterh
				
				s1_a=0.0; //afou tha perasei apo thn prwth sthlh tou depth1
				s1_b=1.0;
				s1_c=0.0;
				
					t2=Math.random();
					if (t2<=0.33){// katw keno
						a2=1.5;
						za2=1.5;
						
						a1=2.0;
						za1=2.0;
						
						a3=2.0;
						za3=2.0;
					}
					else if((t2>0.33) && (t2<=0.66)){// mesaio keno
						a2=2.5;
						za2=0.5;
						
						a1=2.0;
						za1=2.0;
						
						a3=2.0;
						za3=2.0;
					}
					else if(t2>0.66){// panw keno
						a2=0.5;
						za2=2.5;
						
						a1=2.0;
						za1=2.0;
						
						a3=2.0;
						za3=2.0;
					}
				}
				else if(t1>0.66){ //gia thn trith
				
				s1_a=0.0; //afou tha perasei apo thn prwth sthlh tou depth1
				s1_b=0.0;
				s1_c=1.0;
				
					t2=Math.random();
					if (t2<=0.33){// katw keno
						a3=1.5;
						za3=1.5;
						
						a1=2.0;
						za1=2.0;
						
						a2=2.0;
						za2=2.0;
					}
					else if((t2>0.33) && (t2<=0.66)){// mesaio keno
						a3=2.5;
						za3=0.5;
						
						a1=2.0;
						za1=2.0;
						
						a2=2.0;
						za2=2.0;
					}
					else if(t2>0.66){// panw keno
						a3=0.5;
						za3=2.5;
						
						a2=2.0;
						za2=2.0;
						
						a1=2.0;
						za1=2.0;
					}
				}
	}
	
    function RandColumns_2() {
			
			t1=Math.random();
				
			if (t1<=0.33){ //gia thn prwth sthlh
				
				s2_a=1.0; //afou tha perasei apo thn prwth sthlh
				s2_b=0.0;
				s2_c=0.0;
				
					t2=Math.random();
					if (t2<=0.33){// kbtw keno
						b1=1.5;
						zb1=1.5;
						
						b2=2.0;
						zb2=2.0;
						
						b3=2.0;
						zb3=2.0;
					}
					else if((t2>0.33) && (t2<=0.66)){// mesbio keno
						b1=2.5;
						zb1=0.5;
						
						b2=2.0;
						zb2=2.0;
						
						b3=2.0;
						zb3=2.0;
					}
					else if(t2>0.66){// pbnw keno
						b1=0.5;
						zb1=2.5;
						
						b2=2.0;
						zb2=2.0;
						
						b3=2.0;
						zb3=2.0;
					}
				}
			else if((t1>0.33) && (t1<=0.66)){ //gia thn deuterh
			
				s2_a=0.0; //afou tha perasei apo thn prwth sthlh
				s2_b=1.0;
				s2_c=0.0;
				
					if (t2<=0.33){// kbtw keno
						b2=1.5;
						zb2=1.5;
						
						b1=2.0;
						zb1=2.0;
						
						b3=2.0;
						zb3=2.0;
					}
					else if((t2>0.33) && (t2<=0.66)){// mesbio keno
						t2=Math.random();
						b2=2.5;
						zb2=0.5;
						
						b1=2.0;
						zb1=2.0;
						
						b3=2.0;
						zb3=2.0;
					}
					else if(t2>0.66){// pbnw keno
						b2=0.5;
						zb2=2.5;
						
						b1=2.0;
						zb1=2.0;
						
						b3=2.0;
						zb3=2.0;
					}
				}
			else if(t1>0.66){ //gia thn trith
			
				s2_a=0.0; //afou tha perasei apo thn prwth sthlh
				s2_b=0.0;
				s2_c=1.0;
				
					t2=Math.random();
					if (t2<=0.33){// kctw keno
						b3=1.5;
						zb3=1.5;
						
						b1=2.0;
						zb1=2.0;
						
						b2=2.0;
						zb2=2.0;
					}
					else if((t2>0.33) && (t2<=0.66)){// mesbio keno
						b3=2.5;
						zb3=0.5;
						
						b1=2.0;
						zb1=2.0;
						
						b2=2.0;
						zb2=2.0;
					}
					else if(t2>0.66){// pbnw keno
						b3=0.5;
						zb3=2.5;
						
						b2=2.0;
						zb2=2.0;
						
						b1=2.0;
						zb1=2.0;
					}
				}
	}
	
   function RandColumns_3() {
			
				t1=Math.random();
				
				if (t1<=0.33){ //gia thn prwth sthlh
				
				s3_a=1.0; //afou tha perasei apo thn prwth sthlh
				s3_b=0.0;
				s3_c=0.0;
				
					t2=Math.random();
					if (t2<=0.33){// kctw keno
						c1=1.5;
						zc1=1.5;
						
						c2=2.0;
						zc2=2.0;
						
						c3=2.0;
						zc3=2.0;
					}
					else if((t2>0.33) && (t2<=0.66)){// mescio keno
						c1=2.5;
						zc1=0.5;
						
						c2=2.0;
						zc2=2.0;
						
						c3=2.0;
						zc3=2.0;
					}
					else if(t2>0.66){// pcnw keno
						c1=0.5;
						zc1=2.5;
						
						c2=2.0;
						zc2=2.0;
						
						c3=2.0;
						zc3=2.0;
					}
				}
			else if((t1>0.33) && (t1<=0.66)){ //gia thn deuterh
			
			s3_a=0.0; //afou tha perasei apo thn prwth sthlh
			s3_b=1.0;
			s3_c=0.0;
				
					if (t2<=0.33){// kctw keno
						c2=1.5;
						zc2=1.5;
						
						c1=2.0;
						zc1=2.0;
						
						c3=2.0;
						zc3=2.0;
					}
					else if((t2>0.33) && (t2<=0.66)){// mescio keno
						t2=Math.random();
						c2=2.5;
						zc2=0.5;
						
						c1=2.0;
						zc1=2.0;
						
						c3=2.0;
						zc3=2.0;
					}
					else if(t2>0.66){// pcnw keno
						c2=0.5;
						zc2=2.5;
						
						c1=2.0;
						zc1=2.0;
						
						c3=2.0;
						zc3=2.0;
					}
				}
			else if(t1>0.66){ //gia thn trith
			
			s3_a=0.0; //afou tha perasei apo thn prwth sthlh
			s3_b=0.0;
			s3_c=1.0;
				
					t2=Math.random();
					if (t2<=0.33){// kctw keno
						c3=1.5;
						zc3=1.5;
						
						c2=2.0;
						zc2=2.0;
						
						c1=2.0;
						zc1=2.0;
					}
					else if((t2>0.33) && (t2<=0.66)){// mescio keno
						c3=2.5;
						zc3=0.5;
						
						c1=2.0;
						zc1=2.0;
						
						c2=2.0;
						zc2=2.0;
					}
					else if(t2>0.66){// pcnw keno
						c3=0.5;
						zc3=2.5;
						
						c2=2.0;
						zc2=2.0;
						
						c1=2.0;
						zc1=2.0;
					}
				}
	}

	function RandColumns_4() {
			
				t1=Math.random();
				
				if (t1<=0.33){ //gia thn prwth sthlh
				
				s4_a=1.0; //afou tha perasei apo thn prwth sthlh
				s4_b=0.0;
				s4_c=0.0;
				
					t2=Math.random();
					if (t2<=0.33){// kdtw keno
						d1=1.5;
						zd1=1.5;
						
						d2=2.0;
						zd2=2.0;
						
						d3=2.0;
						zd3=2.0;
					}
					else if((t2>0.33) && (t2<=0.66)){// mesdio keno
						d1=2.5;
						zd1=0.5;
						
						d2=2.0;
						zd2=2.0;
						
						d3=2.0;
						zd3=2.0;
					}
					else if(t2>0.66){// pdnw keno
						d1=0.5;
						zd1=2.5;
						
						d2=2.0;
						zd2=2.0;
						
						d3=2.0;
						zd3=2.0;
					}
				}
			else if((t1>0.33) && (t1<=0.66)){ //gia thn deuterh
			
				s4_a=0.0; //afou tha perasei apo thn prwth sthlh
				s4_b=1.0;
				s4_c=0.0;
				
					if (t2<=0.33){// kdtw keno
						d2=1.5;
						zd2=1.5;
						
						d1=2.0;
						zd1=2.0;
						
						d3=2.0;
						zd3=2.0;
					}
					else if((t2>0.33) && (t2<=0.66)){// mesdio keno
						t2=Math.random();
						d2=2.5;
						zd2=0.5;
						
						d1=2.0;
						zd1=2.0;
						
						d3=2.0;
						zd3=2.0;
					}
					else if(t2>0.66){// pdnw keno
						d2=0.5;
						zd2=2.5;
						
						d1=2.0;
						zd1=2.0;
						
						d3=2.0;
						zd3=2.0;
					}
				}
			else if(t1>0.66){ //gia thn trith
			
				s4_a=0.0; //afou tha perasei apo thn prwth sthlh
				s4_b=0.0;
				s4_c=1.0;
				
					t2=Math.random();
					if (t2<=0.33){// kdtw keno
						d3=1.5;
						zd3=1.5;
						
						d1=2.0;
						zd1=2.0;
						
						d2=2.0;
						zd2=2.0;
					}
					else if((t2>0.33) && (t2<=0.66)){// mesdio keno
						d3=2.5;
						zd3=0.5;
						
						d1=2.0;
						zd1=2.0;
						
						d2=2.0;
						zd2=2.0;
					}
					else if(t2>0.66){// pdnw keno
						d3=0.5;
						zd3=2.5;
						
						d2=2.0;
						zd2=2.0;
						
						d1=2.0;
						zd1=2.0;
					}
				}
	}
	
	//this is the requestAnimFrame callback
	//For every tick, request another frame
	//handle keyboard, draw the scene, animate (update animation variebles) and continue
    function tick() {
		
        requestAnimFrame(tick);
        drawScene();
        animate();	
	
    }
	
	function gravity(){
		
		end = new Date().getTime();
		
		timer= (end-beg);
		var a=10;
		distance=((1/2)*a*((timer/10000)*(timer/10000)));
		yTrans=yTrans-distance;
	}
	
	
	function draw() {
				
				RandColumns_1();// gia thn arxikopopoihsh
				RandColumns_2();
				RandColumns_3();
				RandColumns_4();
				
				changeBg2();
                var canvas = document.getElementById("TUCWebGL");
				canvas.addEventListener("mousedown", doMouseDown, false);
	}
				
	function doMouseDown(event) {
	
				 canvas_x = event.pageX;
				 canvas_y = event.pageY;
				 
				 if ((543<canvas_x)&&(canvas_x<907) && (346<canvas_y)&&(canvas_y<430)&&(check==0.0)){ // start game
					
					check=1.0;// an mpei thn prwth fora meta na apenergopoihthoun ta plhktra
					alert("Press MOUSE CLICK or 'W' or UP ARROW to Fly                                                              LEFT/RIGHT ARROW or 'A'/'D' to Navigate                                            Have Fun... :)                                                                   Speed(Levels) Increased Dynamically...");
					changeBg();
					beg = new Date().getTime();
					webGLStart();
				 }
				 else if ((642<canvas_x)&&(canvas_x<815) && (579<canvas_y)&&(canvas_y<640)&&(check==0.0)){ // quit
					//pause();
					alert("Bye Bye.. Have A Flappy Day!");
					var win = window.open("","_self"); /* url = "" or "about:blank"; target="_self" */
					win.close();
				 }
				 else if ((584<canvas_x)&&(canvas_x<878) && (464<canvas_y)&&(canvas_y<541)&&(check==0.0)){ // options
					alert("Press '1' for Bird Cam                                                                    '2' for Panoramic Cam");
				 }
				 else if ((1705<canvas_x)&&(canvas_x<1903) && (853<canvas_y)&&(canvas_y<910)&&(check==0.0)){ // credits
					alert("Sarantaris Eleftherios @TUC");
				 }
				 else if ((10<canvas_x)&&(canvas_x<177) && (695<canvas_y)&&(canvas_y<923)&&(check==0.0)){ // sound
				  
					if (listen==1.0){
						changeBg3();
						play();
						listen=0.0;
					}
					else{
						changeBg2();
						listen=1.0;
						//stop();
						pause();
					}
				 }
				else{
				 }
				//console.log("X=" +xTrans + "   y=" + yTrans);
				}
				
	//Entry point of the WebGL context
	function webGLStart() {
		
		var canvas = document.getElementById("TUCWebGL");
		
		//Functions for initialization
		//Check above
		initGL(canvas);
        initShaders()
        initBuffers();

		//Background Color: Color assigned for all pixels with no corresponding fragments
        //gl.clearColor(0.3, 0.3, 0.3, 1.0);
		
		//Enable z-buffer for depth sorting
        gl.enable(gl.DEPTH_TEST);

		//the first tick of our application
		
        tick();
    }
	
	//end of Javascript
</script>

</head>

<!-- HMTL for the canvas element-->
<body onload="draw();"> <!-- calls the entry point of our application -->


	
    <canvas id="TUCWebGL" style="border: dashed; border-width:0px;	" width="1900" height="934">
	
	
    <br>

</body></html>
